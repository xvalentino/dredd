// Generated by CoffeeScript 1.10.0
var EventEmitter, HANDLER_HOST, HANDLER_MESSAGE_DELIMITER, HANDLER_PORT, HOOK_TIMEOUT, child_process, console, emitter, handler, handlerBuffer, handlerClient, handlerCommand, hooks, language, net, now, pathGlobs, ref, ref1, ref2, ref3, ref4, ref5, spawn, which;

hooks = require('hooks');

net = require('net');

EventEmitter = require('events').EventEmitter;

child_process = require('child_process');

spawn = child_process.spawn;

console = require('console');

which = require('./which');

HOOK_TIMEOUT = (hooks != null ? (ref = hooks.configuration) != null ? (ref1 = ref.options) != null ? ref1['hook-worker-timeout'] : void 0 : void 0 : void 0) || 5000;

HANDLER_HOST = 'localhost';

HANDLER_PORT = 61321;

HANDLER_MESSAGE_DELIMITER = "\n";

emitter = new EventEmitter;

language = hooks != null ? (ref2 = hooks.configuration) != null ? (ref3 = ref2.options) != null ? ref3.language : void 0 : void 0 : void 0;

if (language === 'ruby') {
  handlerCommand = 'dredd-hooks-ruby';
  if (!which.which(handlerCommand)) {
    console.log("Ruby hooks handler server command not found: " + handlerCommand);
    console.log("Install ruby hooks handler by running:");
    console.log("$ gem install dredd_hooks");
    hooks.processExit(1);
  }
} else if (language === 'python') {
  handlerCommand = 'dredd-hooks-python';
  if (!which.which(handlerCommand)) {
    console.log("Python hooks handler server command not found: " + handlerCommand);
    console.log("Install python hooks handler by running:");
    console.log("$ pip install dredd_hooks");
    hooks.processExit(1);
  }
} else if (language === 'nodejs') {
  throw new Error('Hooks handler should not be used for nodejs. Use Dredds\' native node hooks instead');
} else {
  handlerCommand = language;
  if (!which.which(handlerCommand)) {
    console.log("Hooks handler server command not found: " + handlerCommand);
    hooks.processExit(1);
  }
}

pathGlobs = [].concat(hooks != null ? (ref4 = hooks.configuration) != null ? (ref5 = ref4.options) != null ? ref5.hookfiles : void 0 : void 0 : void 0);

handler = spawn(handlerCommand, pathGlobs);

console.log("Spawning `" + language + "` hooks handler");

handler.stdout.on('data', function(data) {
  return console.log("Hook handler stdout:", data.toString());
});

handler.stderr.on('data', function(data) {
  return console.log("Hook handler stderr:", data.toString());
});

handler.on('close', function(status) {
  console.log("Hook handler closed with status: " + status);
  if ((status != null) && status !== 0) {
    return hooks.processExit(2);
  }
});

handler.on('error', function(error) {
  return console.log(error);
});

now = new Date().getTime();

while (new Date().getTime() < now + 1000) {
  true;
}

handlerClient = net.connect({
  port: HANDLER_PORT,
  host: HANDLER_HOST
}, function() {});

handlerClient.on('error', function(error) {
  console.log('Error connecting to the hook handler. Is the handler running?');
  console.log(error);
  return hooks.processExit(3);
});

handlerBuffer = "";

handlerClient.on('data', function(data) {
  var i, j, len, len1, message, messages, results, splittedData;
  handlerBuffer += data.toString();
  if (data.toString().indexOf(HANDLER_MESSAGE_DELIMITER) > -1) {
    splittedData = handlerBuffer.split(HANDLER_MESSAGE_DELIMITER);
    handlerBuffer = splittedData.pop();
    messages = [];
    for (i = 0, len = splittedData.length; i < len; i++) {
      message = splittedData[i];
      messages.push(JSON.parse(message));
    }
    results = [];
    for (j = 0, len1 = messages.length; j < len1; j++) {
      message = messages[j];
      if (message.uuid != null) {
        results.push(emitter.emit(message.uuid, message));
      } else {
        results.push(console.log('UUID not present in message: ', JSON.stringify(message, null, 2)));
      }
    }
    return results;
  }
});

now = new Date().getTime();

while (new Date().getTime() < now + 1000) {
  true;
}

hooks.beforeEach(function(transaction, callback) {
  var handleTimeout, message, messageHandler, timeout, uuid;
  uuid = Date.now().toString() + '-' + Math.random().toString(36).substring(7);
  message = {
    event: 'beforeEach',
    uuid: uuid,
    data: transaction
  };
  handlerClient.write(JSON.stringify(message));
  handlerClient.write(HANDLER_MESSAGE_DELIMITER);
  messageHandler = function(receivedMessage) {
    var key, ref6, value;
    clearTimeout(timeout);
    ref6 = receivedMessage.data;
    for (key in ref6) {
      value = ref6[key];
      transaction[key] = value;
    }
    return callback();
  };
  handleTimeout = function() {
    transaction.fail = 'Hook timed out.';
    emitter.removeListener(uuid, messageHandler);
    return callback();
  };
  timeout = setTimeout(handleTimeout, HOOK_TIMEOUT);
  return emitter.on(uuid, messageHandler);
});

hooks.beforeEachValidation(function(transaction, callback) {
  var handleTimeout, message, messageHandler, timeout, uuid;
  uuid = Date.now().toString() + '-' + Math.random().toString(36).substring(7);
  message = {
    event: 'beforeEachValidation',
    uuid: uuid,
    data: transaction
  };
  handlerClient.write(JSON.stringify(message));
  handlerClient.write(HANDLER_MESSAGE_DELIMITER);
  messageHandler = function(receivedMessage) {
    var key, ref6, value;
    clearTimeout(timeout);
    ref6 = receivedMessage.data;
    for (key in ref6) {
      value = ref6[key];
      transaction[key] = value;
    }
    return callback();
  };
  handleTimeout = function() {
    transaction.fail = 'Hook timed out.';
    emitter.removeListener(uuid, messageHandler);
    return callback();
  };
  timeout = setTimeout(handleTimeout, HOOK_TIMEOUT);
  return emitter.on(uuid, messageHandler);
});

hooks.afterEach(function(transaction, callback) {
  var handleTimeout, message, messageHandler, timeout, uuid;
  uuid = Date.now().toString() + '-' + Math.random().toString(36).substring(7);
  message = {
    event: 'afterEach',
    uuid: uuid,
    data: transaction
  };
  handlerClient.write(JSON.stringify(message));
  handlerClient.write(HANDLER_MESSAGE_DELIMITER);
  messageHandler = function(receivedMessage) {
    var key, ref6, value;
    clearTimeout(timeout);
    ref6 = receivedMessage.data;
    for (key in ref6) {
      value = ref6[key];
      transaction[key] = value;
    }
    return callback();
  };
  handleTimeout = function() {
    transaction.fail = 'Hook timed out.';
    emitter.removeListener(uuid, messageHandler);
    return callback();
  };
  timeout = setTimeout(handleTimeout, HOOK_TIMEOUT);
  return emitter.on(uuid, messageHandler);
});

hooks.beforeAll(function(transactions, callback) {
  var handleTimeout, message, messageHandler, timeout, uuid;
  uuid = Date.now().toString() + '-' + Math.random().toString(36).substring(7);
  message = {
    event: 'beforeAll',
    uuid: uuid,
    data: transactions
  };
  handlerClient.write(JSON.stringify(message));
  handlerClient.write(HANDLER_MESSAGE_DELIMITER);
  messageHandler = function(receivedMessage) {
    var i, index, len, ref6, value;
    clearTimeout(timeout);
    ref6 = receivedMessage.data;
    for (index = i = 0, len = ref6.length; i < len; index = ++i) {
      value = ref6[index];
      transactions[index] = value;
    }
    return callback();
  };
  handleTimeout = function() {
    console.log('Hook timed out.');
    emitter.removeListener(uuid, messageHandler);
    return callback();
  };
  timeout = setTimeout(handleTimeout, HOOK_TIMEOUT);
  return emitter.on(uuid, messageHandler);
});

hooks.afterAll(function(transactions, callback) {
  var handleTimeout, message, messageHandler, timeout, uuid;
  uuid = Date.now().toString() + '-' + Math.random().toString(36).substring(7);
  message = {
    event: 'afterAll',
    uuid: uuid,
    data: transactions
  };
  handlerClient.write(JSON.stringify(message));
  handlerClient.write(HANDLER_MESSAGE_DELIMITER);
  messageHandler = function(receivedMessage) {
    var i, index, len, ref6, value;
    clearTimeout(timeout);
    ref6 = receivedMessage.data;
    for (index = i = 0, len = ref6.length; i < len; index = ++i) {
      value = ref6[index];
      transactions[index] = value;
    }
    return callback();
  };
  handleTimeout = function() {
    console.log('Hook timed out.');
    emitter.removeListener(uuid, messageHandler);
    return callback();
  };
  timeout = setTimeout(handleTimeout, HOOK_TIMEOUT);
  return emitter.on(uuid, messageHandler);
});

hooks.afterAll(function(transactions, callback) {
  var i, index, len, mod, ref6;
  handler.kill('SIGKILL');
  if (process.env['TEST_DREDD_HOOKS_HANDLER_ORDER'] === "true") {
    console.log('FOR TESTING ONLY');
    ref6 = transactions[0]['hooks_modifications'];
    for (index = i = 0, len = ref6.length; i < len; index = ++i) {
      mod = ref6[index];
      console.log(index + " " + mod);
    }
    console.log('FOR TESTING ONLY');
  }
  return callback();
});
